{{/* Scripts - Theme toggle, Mobile menu, Animations */}}

<script>
  (function () {
    "use strict";

    // ===== Theme Toggle Logic =====
    function setTheme(theme) {
      document.documentElement.setAttribute("data-theme", theme);
      localStorage.setItem("theme", theme);
      
      // Sync checkbox state if it exists
      const checkbox = document.getElementById("theme-toggle");
      if (checkbox) checkbox.checked = theme === "dark";
    }

    // Mobile Toggle (Simple Click)
    const mobileToggle = document.getElementById("theme-toggle-mobile");
    if (mobileToggle) {
      mobileToggle.addEventListener("click", () => {
        const current = document.documentElement.getAttribute("data-theme");
        setTheme(current === "dark" ? "light" : "dark");
      });
    }

    // Desktop Drag Toggle (iOS Physics + Live Feedback)
    const desktopSwitch = document.querySelector(".theme-switch");
    const slider = desktopSwitch?.querySelector(".theme-switch__slider");

    if (desktopSwitch && slider) {
      let isDragging = false;
      let startX = 0;
      let initialKnobX = 0;
      
      // Prevent "Ghost Clicks" from the label triggering the checkbox
      desktopSwitch.addEventListener("click", (e) => {
        // If it was a mouse click (detail 1) or we were just dragging, kill it.
        // We only allow keyboard activation (detail 0)
        if (e.detail !== 0) {
          e.preventDefault();
          e.stopPropagation();
        } else {
             // Keyboard activation
           const current = document.documentElement.getAttribute("data-theme");
           setTheme(current === "dark" ? "light" : "dark");
        }
      }, true); // Capture phase to ensure we stop it before it hits the input

      desktopSwitch.addEventListener("pointerdown", (e) => {
        // Stop default to prevent text selection or focus weirdness
        e.preventDefault(); 
        
        isDragging = true;
        startX = e.clientX;
        
        // Force-read current state to ensure initialKnobX is correct
        const currentTheme = document.documentElement.getAttribute("data-theme") || "light";
        initialKnobX = currentTheme === "dark" ? 38 : 0;
        
        // Fix "Jump" Glitch: Set the position explicitly BEFORE removing transitions with .dragging
        slider.style.setProperty("--knob-x", `${initialKnobX}px`);
        
        slider.classList.add("dragging");
        slider.setPointerCapture(e.pointerId);
      });

      desktopSwitch.addEventListener("pointermove", (e) => {
        if (!isDragging) return;
        
        const delta = e.clientX - startX;
        let newX = initialKnobX + delta;
        
        // Rubber Banding
        if (newX < 0) newX = newX * 0.4;
        else if (newX > 38) newX = 38 + (newX - 38) * 0.4;
        
        slider.style.setProperty("--knob-x", `${newX}px`);
        
        // Live Toggle with Hysteresis
        // Thresholds: Light < 14 | Dark > 24
        const currentTheme = document.documentElement.getAttribute("data-theme");
        
        if (currentTheme !== "dark" && newX > 24) {
             setTheme("dark");
             if (navigator.vibrate) navigator.vibrate(10);
        } else if (currentTheme === "dark" && newX < 14) {
             setTheme("light");
             if (navigator.vibrate) navigator.vibrate(10);
        }
      });

      desktopSwitch.addEventListener("pointerup", (e) => {
        if (!isDragging) return;
        
        isDragging = false;
        slider.classList.remove("dragging");
        slider.style.removeProperty("--knob-x");
        slider.releasePointerCapture(e.pointerId);
        
        const delta = e.clientX - startX;
        
        // 1. Naive Click Check (< 4px movement) - Treated as a simple toggle
        if (Math.abs(delta) < 4) {
          const current = document.documentElement.getAttribute("data-theme");
          setTheme(current === "dark" ? "light" : "dark");
          return;
        }
        
        // 2. Drag Release Logic
        // We used Live Toggle, so the "currentTheme" is ALREADY updated to what the user saw.
        // We just need to ensure the CSS snaps to that same state.
        
        // Calculate where the knob "physically" is (clamped for logic safety)
        let finalRaw = initialKnobX + delta;
        let finalClamped = Math.max(0, Math.min(38, finalRaw));
        
        // Decision Threshold (Midpoint 19px)
        // If knob is > 19, it SHOULD be Dark. If < 19, it SHOULD be Light.
        const shouldBeDark = finalClamped > 19;
        const targetTheme = shouldBeDark ? "dark" : "light";
        
        // Enforce the visual state matches the physical position
        const actualTheme = document.documentElement.getAttribute("data-theme");
        
        if (actualTheme !== targetTheme) {
            setTheme(targetTheme);
        }
      });
      
      desktopSwitch.addEventListener("pointercancel", (e) => {
        isDragging = false;
        slider.classList.remove("dragging");
        slider.style.removeProperty("--knob-x");
      });
    }

    // ===== Mobile Menu =====
    const mobileMenuBtn = document.getElementById("mobile-menu-btn");
    const mobileMenu = document.getElementById("mobile-menu");
    const mobileMenuOverlay = document.getElementById("mobile-menu-overlay");

    function openMobileMenu() {
      mobileMenuBtn.classList.add("open");
      mobileMenuBtn.setAttribute("aria-expanded", "true");
      mobileMenu.classList.add("open");
      mobileMenu.setAttribute("aria-hidden", "false");
      mobileMenuOverlay.classList.add("show");
      document.body.style.overflow = "hidden";
    }

    function closeMobileMenu() {
      mobileMenuBtn.classList.remove("open");
      mobileMenuBtn.setAttribute("aria-expanded", "false");
      mobileMenu.classList.remove("open");
      mobileMenu.setAttribute("aria-hidden", "true");
      mobileMenuOverlay.classList.remove("show");
      document.body.style.overflow = "";
    }

    if (mobileMenuBtn) {
      mobileMenuBtn.addEventListener("click", () => {
        const isOpen = mobileMenuBtn.classList.contains("open");
        if (isOpen) {
          closeMobileMenu();
        } else {
          openMobileMenu();
        }
      });
    }

    if (mobileMenuOverlay) {
      mobileMenuOverlay.addEventListener("click", closeMobileMenu);
    }

    // Close on escape key
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        closeMobileMenu();
        // Also close dropdown
        const dropdowns = document.querySelectorAll(".nav-split-btn.open");
        dropdowns.forEach((d) => d.classList.remove("open"));
      }
    });

    // ===== Blog Dropdown =====
    const blogDropdownBtn = document.getElementById("blog-dropdown-btn");
    const blogSplitBtn = blogDropdownBtn?.closest(".nav-split-btn");

    if (blogDropdownBtn && blogSplitBtn) {
      blogDropdownBtn.addEventListener("click", (e) => {
        e.preventDefault();
        const isOpen = blogSplitBtn.classList.contains("open");

        // Close other dropdowns first
        document.querySelectorAll(".nav-split-btn.open").forEach((d) => {
          if (d !== blogSplitBtn) d.classList.remove("open");
        });

        if (isOpen) {
          blogSplitBtn.classList.remove("open");
          blogDropdownBtn.setAttribute("aria-expanded", "false");
        } else {
          blogSplitBtn.classList.add("open");
          blogDropdownBtn.setAttribute("aria-expanded", "true");
        }
      });

      // Close dropdown when clicking outside
      document.addEventListener("click", (e) => {
        if (!blogSplitBtn.contains(e.target)) {
          blogSplitBtn.classList.remove("open");
          blogDropdownBtn.setAttribute("aria-expanded", "false");
        }
      });
    }

    // ===== Scroll Reveal Animation =====
    const revealElements = document.querySelectorAll(".reveal");

    const revealObserver = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            entry.target.classList.add("visible");
            revealObserver.unobserve(entry.target);
          }
        });
      },
      {
        threshold: 0.1,
        rootMargin: "0px 0px -50px 0px",
      }
    );

    revealElements.forEach((el) => revealObserver.observe(el));

    // ===== Smooth Scroll for anchor links =====
    document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
      anchor.addEventListener("click", function (e) {
        const href = this.getAttribute("href");
        if (href.length > 1) {
          e.preventDefault();
          const target = document.querySelector(href);
          if (target) {
            target.scrollIntoView({ behavior: "smooth" });
          }
        }
      });
    });

    // ===== Progress bar animation on scroll (for skills) =====
    const progressBars = document.querySelectorAll(".progress-bar-fill");

    const progressObserver = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            const fill = entry.target;
            const width = fill.getAttribute("data-width");
            if (width) {
              fill.style.width = width;
            }
            progressObserver.unobserve(fill);
          }
        });
      },
      { threshold: 0.5 }
    );

    progressBars.forEach((bar) => {
      // Store the target width and set initial width to 0
      const targetWidth = bar.style.width;
      bar.setAttribute("data-width", targetWidth);
      bar.style.width = "0";
      progressObserver.observe(bar);
    });

    // ===== Copy Code Button =====
    document.querySelectorAll("pre").forEach((pre) => {
      // Create copy button
      const copyBtn = document.createElement("button");
      copyBtn.className = "copy-code-btn";
      copyBtn.innerHTML = `
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <rect width="14" height="14" x="8" y="8" rx="2" ry="2"/>
          <path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/>
        </svg>
        <span>Copy</span>
      `;

      copyBtn.addEventListener("click", async () => {
        const code = pre.querySelector("code")?.textContent || pre.textContent;
        try {
          await navigator.clipboard.writeText(code);
          copyBtn.classList.add("copied");
          copyBtn.querySelector("span").textContent = "Copied!";
          setTimeout(() => {
            copyBtn.classList.remove("copied");
            copyBtn.querySelector("span").textContent = "Copy";
          }, 2000);
        } catch (err) {
          console.error("Failed to copy:", err);
        }
      });

      pre.appendChild(copyBtn);
    });
    // ===== Nav Highlight Controller (Theme Toggle Style - iOS Physics) =====
    (function initNavHighlight() {
      const navContainer = document.querySelector(".nav-items");
      const navHighlight = document.getElementById("nav-highlight");
      if (!navContainer || !navHighlight) return;

      // State
      let isDragging = false;
      let startX = 0;
      let startY = 0;
      let currentTarget = null;
      let startTarget = null;
      let holdTimer = null; // Timer for hold-to-open dropdown
      let initialPillLeft = 0; // For pixel-perfect drag tracking
      let currentPillWidth = 0; // Current pill width

      // ===== Helpers =====
      function getNavItemFromPoint(x, y) {
        // Don't use elementFromPoint - glass pseudo-elements intercept it
        // Instead, iterate through nav items and check bounding rect
        const items = navContainer.querySelectorAll(".nav-item, .nav-split-btn");
        for (const item of items) {
          const rect = item.getBoundingClientRect();
          if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
            return item;
          }
        }
        
        // Also check dropdown items when dropdown is open
        const dropdownItems = document.querySelectorAll(".dropdown.show .dropdown-item, .nav-split-btn.open .dropdown-item");
        for (const item of dropdownItems) {
          const rect = item.getBoundingClientRect();
          if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
            return item; // Return dropdown item itself
          }
        }
        
        return null;
      }

      function getNavItemFromEvent(e) {
        // Don't intercept dropdown toggle
        if (e.target.closest(".nav-split-toggle")) return null;
        return e.target.closest(".nav-item, .nav-split-btn");
      }

      function getPillPosition(target) {
        if (!target) return null;
        const rect = target.getBoundingClientRect();
        const containerRect = navContainer.getBoundingClientRect();
        return {
          left: rect.left - containerRect.left,
          width: rect.width
        };
      }

      // ===== Hold-to-Open Dropdown =====
      function startHoldTimer(target) {
        clearHoldTimer();
        const splitBtn = target.classList.contains("nav-split-btn") ? target : null;
        if (!splitBtn) return;
        
        holdTimer = setTimeout(() => {
          splitBtn.classList.add("open");
          const dropdownBtn = splitBtn.querySelector(".nav-split-toggle");
          if (dropdownBtn) dropdownBtn.setAttribute("aria-expanded", "true");
          if (navigator.vibrate) navigator.vibrate(15);
        }, 500);
      }
      
      function clearHoldTimer() {
        if (holdTimer) {
          clearTimeout(holdTimer);
          holdTimer = null;
        }
      }

      // ===== Pill Control (CSS Variables like Theme Toggle) =====
      function movePillTo(target, animate = true) {
        // Handle dropdown items specially
        const isDropdownItem = target.classList.contains("dropdown-item");
        let pillTarget = target;
        
        if (isDropdownItem) {
          // For dropdown items, keep pill at the parent nav-split-btn
          const dropdown = target.closest(".nav-split-btn, .dropdown");
          pillTarget = dropdown?.closest(".nav-split-btn") || navContainer.querySelector(".nav-split-btn.open");
          if (!pillTarget) pillTarget = target;
        }
        
        const pos = getPillPosition(pillTarget);
        if (!pos) return;

        // Toggle transition via .dragging class (like Theme Toggle)
        if (!animate) {
          navHighlight.classList.add("dragging");
        } else {
          navHighlight.classList.remove("dragging");
        }

        // Set CSS variables (like --knob-x in Theme Toggle)
        navHighlight.style.setProperty("--pill-left", `${pos.left}px`);
        navHighlight.style.setProperty("--pill-width", `${pos.width}px`);
        navHighlight.style.opacity = "1";

        // Update text highlight
        document.querySelectorAll(".nav-dragging").forEach(el => el.classList.remove("nav-dragging"));
        
        if (isDropdownItem) {
          // Highlight the dropdown item
          target.classList.add("nav-dragging");
        } else if (target.classList.contains("nav-split-btn")) {
          target.querySelector(".nav-split-main")?.classList.add("nav-dragging");
        } else {
          target.classList.add("nav-dragging");
        }

        currentTarget = target;
      }

      function returnToActive() {
        navHighlight.classList.remove("dragging");
        const active = navContainer.querySelector(".nav-item.active, .nav-split-main.active");
        if (active) {
          const target = active.closest(".nav-split-btn") || active;
          movePillTo(target, true);
        } else {
          navHighlight.style.opacity = "0";
        }
        document.querySelectorAll(".nav-dragging").forEach(el => el.classList.remove("nav-dragging"));
        navContainer.classList.remove("nav-interacting");
      }

      // ===== Global Drag Handler (for tracking outside nav container) =====
      function handleGlobalDragMove(e) {
        if (!isDragging) return;
        
        const target = getNavItemFromPoint(e.clientX, e.clientY);
        const isOverDropdownItem = target && target.classList.contains("dropdown-item");
        const wasOverDropdownItem = currentTarget && currentTarget.classList.contains("dropdown-item");
        const blogSplit = navContainer.querySelector(".nav-split-btn");
        const dropdownMenu = blogSplit?.querySelector(".dropdown-menu");
        
        // Check if cursor is within dropdown menu bounds (even if not on an item)
        let cursorInDropdownArea = false;
        if (dropdownMenu && blogSplit?.classList.contains("open")) {
          const dropdownRect = dropdownMenu.getBoundingClientRect();
          cursorInDropdownArea = (
            e.clientX >= dropdownRect.left &&
            e.clientX <= dropdownRect.right &&
            e.clientY >= dropdownRect.top &&
            e.clientY <= dropdownRect.bottom
          );
        }
        
        // Check if cursor is heading towards dropdown (below Blog button, within X range)
        let cursorHeadingToDropdown = false;
        if (blogSplit && currentTarget === blogSplit) {
          const blogRect = blogSplit.getBoundingClientRect();
          cursorHeadingToDropdown = (
            e.clientY > blogRect.bottom &&
            e.clientX >= blogRect.left &&
            e.clientX <= blogRect.right
          );
        }
        
        // Check if leaving Blog area
        const wasOnBlog = wasOverDropdownItem || currentTarget === blogSplit;
        const isOnBlog = isOverDropdownItem || target === blogSplit || cursorInDropdownArea || cursorHeadingToDropdown;
        
        // Close dropdown when leaving Blog area (but not if cursor is in dropdown area or heading towards it)
        if (wasOnBlog && !isOnBlog) {
          blogSplit?.classList.remove("open");
          const toggleBtn = blogSplit?.querySelector(".nav-split-toggle");
          if (toggleBtn) toggleBtn.setAttribute("aria-expanded", "false");
          
          // Instantly position pill at cursor and continue tracking (no delay)
          const containerRect = navContainer.getBoundingClientRect();
          const cursorRelativeX = e.clientX - containerRect.left;
          let newLeft = cursorRelativeX - currentPillWidth / 2;
          
          // Clamp to nav item bounds
          const allItems = navContainer.querySelectorAll(".nav-item, .nav-split-btn");
          const firstPos = getPillPosition(allItems[0]);
          const lastPos = getPillPosition(allItems[allItems.length - 1]);
          const minLeft = firstPos?.left || 0;
          const maxLeft = lastPos?.left || containerRect.width - currentPillWidth;
          newLeft = Math.max(minLeft, Math.min(maxLeft, newLeft));
          
          // Set position instantly (keep .dragging class for no transition)
          navHighlight.style.setProperty("--pill-left", `${newLeft}px`);
          
          // Update width to new target if exists
          if (target && !target.classList.contains("dropdown-item")) {
            const newPos = getPillPosition(target);
            if (newPos) {
              currentPillWidth = newPos.width;
              navHighlight.style.setProperty("--pill-width", `${newPos.width}px`);
            }
          }
          
          // Reset tracking immediately (no setTimeout)
          initialPillLeft = newLeft;
          startX = e.clientX;
        } else if (isOverDropdownItem) {
          // Inside dropdown - lock pill at Blog position
          const blogPos = getPillPosition(blogSplit);
          if (blogPos) {
            navHighlight.style.setProperty("--pill-left", `${blogPos.left}px`);
            navHighlight.style.setProperty("--pill-width", `${blogPos.width}px`);
          }
        } else {
          // Normal tracking (works even outside nav container)
          const containerRect = navContainer.getBoundingClientRect();
          const delta = e.clientX - startX;
          let newLeft = initialPillLeft + delta;
          
          // Clamp to first and last nav item positions
          const allItems = navContainer.querySelectorAll(".nav-item, .nav-split-btn");
          const firstItem = allItems[0];
          const lastItem = allItems[allItems.length - 1];
          
          if (firstItem && lastItem) {
            const firstPos = getPillPosition(firstItem);
            const lastPos = getPillPosition(lastItem);
            const minLeft = firstPos ? firstPos.left : 0;
            const maxLeft = lastPos ? lastPos.left : containerRect.width - currentPillWidth;
            newLeft = Math.max(minLeft, Math.min(maxLeft, newLeft));
          }
          
          navHighlight.style.setProperty("--pill-left", `${newLeft}px`);
        }
        
        // Update text highlight AND pill width when target changes
        if (target && target !== currentTarget) {
          // Update pill width to match new target (fix shrinking issue)
          if (!target.classList.contains("dropdown-item")) {
            const newPos = getPillPosition(target);
            if (newPos) {
              currentPillWidth = newPos.width;
              navHighlight.style.setProperty("--pill-width", `${newPos.width}px`);
            }
          }
          
          document.querySelectorAll(".nav-dragging").forEach(el => el.classList.remove("nav-dragging"));
          if (target.classList.contains("dropdown-item")) {
            target.classList.add("nav-dragging");
          } else if (target.classList.contains("nav-split-btn")) {
            target.querySelector(".nav-split-main")?.classList.add("nav-dragging");
          } else {
            target.classList.add("nav-dragging");
          }
          currentTarget = target;
          startHoldTimer(target);
        }
      }

      // ===== Initialize on Load =====
      setTimeout(() => {
        const active = navContainer.querySelector(".nav-item.active, .nav-split-main.active");
        if (active) {
          const target = active.closest(".nav-split-btn") || active;
          // Position instantly (no animation)
          navHighlight.classList.add("dragging");
          const pos = getPillPosition(target);
          if (pos) {
            navHighlight.style.setProperty("--pill-left", `${pos.left}px`);
            navHighlight.style.setProperty("--pill-width", `${pos.width}px`);
            navHighlight.style.opacity = "1";
          }
          // Re-enable transitions after paint
          requestAnimationFrame(() => {
            navHighlight.classList.remove("dragging");
          });
        }
      }, 50);

      // ===== POINTER DOWN (Start Drag - Like Theme Toggle) =====
      navContainer.addEventListener("pointerdown", (e) => {
        if (e.button !== 0) return;
        
        // Don't intercept dropdown toggle clicks
        if (e.target.closest(".nav-split-toggle")) return;

        const target = getNavItemFromEvent(e);
        if (!target) return;

        e.preventDefault();
        isDragging = true;
        startX = e.clientX;
        startY = e.clientY;
        startTarget = target;
        currentTarget = target;

        navContainer.classList.add("nav-interacting");
        
        // Add dragging class to disable transitions (like Theme Toggle line 63)
        navHighlight.classList.add("dragging");
        
        // Capture pointer on CONTAINER (highlight has pointer-events: none)
        navContainer.setPointerCapture(e.pointerId);
        
        // Position pill at target and capture initial position (like Theme Toggle initialKnobX)
        const pos = getPillPosition(target);
        if (pos) {
          initialPillLeft = pos.left;
          currentPillWidth = pos.width;
          navHighlight.style.setProperty("--pill-left", `${pos.left}px`);
          navHighlight.style.setProperty("--pill-width", `${pos.width}px`);
          navHighlight.style.opacity = "1";
        }
        
        // Update text highlight
        document.querySelectorAll(".nav-dragging").forEach(el => el.classList.remove("nav-dragging"));
        if (target.classList.contains("nav-split-btn")) {
          target.querySelector(".nav-split-main")?.classList.add("nav-dragging");
        } else {
          target.classList.add("nav-dragging");
        }
        
        // Start hold timer for dropdown
        startHoldTimer(target);
        
        // Add global listener for tracking outside nav container
        document.addEventListener("pointermove", handleGlobalDragMove);
      });

      // ===== POINTER MOVE (Drag - Like Theme Toggle) =====
      navContainer.addEventListener("pointermove", (e) => {
        // Handle drag - PIXEL PERFECT like Theme Toggle
        if (isDragging) {
          const target = getNavItemFromPoint(e.clientX, e.clientY);
          const isOverDropdownItem = target && target.classList.contains("dropdown-item");
          const wasOverDropdownItem = currentTarget && currentTarget.classList.contains("dropdown-item");
          const blogSplit = navContainer.querySelector(".nav-split-btn");
          const dropdownMenu = blogSplit?.querySelector(".dropdown-menu");
          
          // Check if cursor is within dropdown menu bounds (even if not on an item)
          let cursorInDropdownArea = false;
          if (dropdownMenu && blogSplit?.classList.contains("open")) {
            const dropdownRect = dropdownMenu.getBoundingClientRect();
            cursorInDropdownArea = (
              e.clientX >= dropdownRect.left &&
              e.clientX <= dropdownRect.right &&
              e.clientY >= dropdownRect.top &&
              e.clientY <= dropdownRect.bottom
            );
          }
          
          // Check if cursor is heading towards dropdown (below Blog button, within X range)
          let cursorHeadingToDropdown = false;
          if (blogSplit && currentTarget === blogSplit) {
            const blogRect = blogSplit.getBoundingClientRect();
            cursorHeadingToDropdown = (
              e.clientY > blogRect.bottom &&
              e.clientX >= blogRect.left &&
              e.clientX <= blogRect.right
            );
          }
          
          // Check if leaving Blog area (was on Blog/dropdown, now on different nav item)
          const wasOnBlog = wasOverDropdownItem || currentTarget === blogSplit;
          const isOnBlog = isOverDropdownItem || target === blogSplit || cursorInDropdownArea || cursorHeadingToDropdown;
          
          // Close dropdown when leaving Blog area (but not if cursor is in dropdown area or heading towards it)
          if (wasOnBlog && !isOnBlog) {
            blogSplit?.classList.remove("open");
            const toggleBtn = blogSplit?.querySelector(".nav-split-toggle");
            if (toggleBtn) toggleBtn.setAttribute("aria-expanded", "false");
            
            // Instantly position pill at cursor and continue tracking (no delay)
            const containerRect = navContainer.getBoundingClientRect();
            const cursorRelativeX = e.clientX - containerRect.left;
            let newLeft = cursorRelativeX - currentPillWidth / 2;
            
            // Clamp to nav item bounds
            const allItems = navContainer.querySelectorAll(".nav-item, .nav-split-btn");
            const firstPos = getPillPosition(allItems[0]);
            const lastPos = getPillPosition(allItems[allItems.length - 1]);
            const minLeft = firstPos?.left || 0;
            const maxLeft = lastPos?.left || containerRect.width - currentPillWidth;
            newLeft = Math.max(minLeft, Math.min(maxLeft, newLeft));
            
            // Set position instantly (keep .dragging class for no transition)
            navHighlight.style.setProperty("--pill-left", `${newLeft}px`);
            
            // Update width to new target if exists
            if (target && !target.classList.contains("dropdown-item")) {
              const newPos = getPillPosition(target);
              if (newPos) {
                currentPillWidth = newPos.width;
                navHighlight.style.setProperty("--pill-width", `${newPos.width}px`);
              }
            }
            
            // Reset tracking immediately (no setTimeout)
            initialPillLeft = newLeft;
            startX = e.clientX;
          } else if (isOverDropdownItem) {
            // Inside dropdown - lock pill at Blog position
            const blogPos = getPillPosition(blogSplit);
            if (blogPos) {
              navHighlight.style.setProperty("--pill-left", `${blogPos.left}px`);
              navHighlight.style.setProperty("--pill-width", `${blogPos.width}px`);
            }
          } else {
            // Normal nav item or outside - pixel-perfect tracking
            const containerRect = navContainer.getBoundingClientRect();
            const delta = e.clientX - startX;
            let newLeft = initialPillLeft + delta;
            
            // Clamp to first and last nav item positions (not container edges)
            const allItems = navContainer.querySelectorAll(".nav-item, .nav-split-btn");
            const firstItem = allItems[0];
            const lastItem = allItems[allItems.length - 1];
            
            if (firstItem && lastItem) {
              const firstPos = getPillPosition(firstItem);
              const lastPos = getPillPosition(lastItem);
              const minLeft = firstPos ? firstPos.left : 0;
              const maxLeft = lastPos ? lastPos.left : containerRect.width - currentPillWidth;
              newLeft = Math.max(minLeft, Math.min(maxLeft, newLeft));
            }
            
            navHighlight.style.setProperty("--pill-left", `${newLeft}px`);
          }
          
          // Update text highlight AND pill width when target changes
          if (target && target !== currentTarget) {
            // Update pill width to match new target (fix shrinking issue)
            if (!target.classList.contains("dropdown-item")) {
              const newPos = getPillPosition(target);
              if (newPos) {
                currentPillWidth = newPos.width;
                navHighlight.style.setProperty("--pill-width", `${newPos.width}px`);
              }
            }
            
            document.querySelectorAll(".nav-dragging").forEach(el => el.classList.remove("nav-dragging"));
            if (target.classList.contains("dropdown-item")) {
              target.classList.add("nav-dragging");
            } else if (target.classList.contains("nav-split-btn")) {
              target.querySelector(".nav-split-main")?.classList.add("nav-dragging");
            } else {
              target.classList.add("nav-dragging");
            }
            currentTarget = target;
            // Reset hold timer for new target
            startHoldTimer(target);
          }
          return;
        }
        
        // Handle hover (non-drag)
        const target = getNavItemFromEvent(e);
        if (target && target !== currentTarget) {
          navContainer.classList.add("nav-interacting");
          movePillTo(target, true);
        }
      });

      // ===== POINTER UP (Release - Like Theme Toggle) =====
      navContainer.addEventListener("pointerup", (e) => {
        clearHoldTimer();
        
        if (!isDragging) return;

        isDragging = false;
        navHighlight.classList.remove("dragging");
        navContainer.releasePointerCapture(e.pointerId);
        
        // Remove global listener
        document.removeEventListener("pointermove", handleGlobalDragMove);

        const deltaX = e.clientX - startX;
        const deltaY = e.clientY - startY;
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

        // Click detection: < 4px movement (like Theme Toggle line 103)
        if (distance < 4) {
          // It's a click - navigate
          navContainer.classList.remove("nav-interacting");
          
          if (startTarget) {
            // Handle dropdown item
            if (startTarget.classList.contains("dropdown-item") && startTarget.href) {
              window.location.href = startTarget.href;
              return;
            }
            const link = startTarget.classList.contains("nav-split-btn")
              ? startTarget.querySelector(".nav-split-main")
              : startTarget;
            if (link && link.href) {
              window.location.href = link.href;
            }
          }
          return;
        }

        // It's a drag - navigate to final target
        const finalTarget = getNavItemFromPoint(e.clientX, e.clientY);
        navContainer.classList.remove("nav-interacting");
        
        if (finalTarget) {
          // Handle dropdown item
          if (finalTarget.classList.contains("dropdown-item") && finalTarget.href) {
            window.location.href = finalTarget.href;
            return;
          }
          const link = finalTarget.classList.contains("nav-split-btn")
            ? finalTarget.querySelector(".nav-split-main")
            : finalTarget;
          if (link && link.href) {
            window.location.href = link.href;
          }
        } else {
          // Released outside - return to active
          returnToActive();
        }
      });

      // ===== POINTER CANCEL =====
      navContainer.addEventListener("pointercancel", () => {
        clearHoldTimer();
        isDragging = false;
        navHighlight.classList.remove("dragging");
        document.removeEventListener("pointermove", handleGlobalDragMove);
        returnToActive();
      });

      // ===== HOVER ENTER =====
      navContainer.addEventListener("pointerenter", (e) => {
        if (isDragging) return;
        const target = getNavItemFromEvent(e);
        if (target) {
          navContainer.classList.add("nav-interacting");
          movePillTo(target, true);
        }
      });

      // ===== POINTER LEAVE =====
      navContainer.addEventListener("pointerleave", () => {
        if (isDragging) return;
        returnToActive();
      });

    })();
  })();
</script>

{{/* Structured Data */}} {{ if .IsPage }} {{ partial "schema/blogposting.html" . }} {{ end }}

{{/* Mermaid.js Diagram Support */}}
<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ 
    startOnLoad: true,
    theme: 'dark',
    securityLevel: 'loose',
    fontFamily: 'Inter, sans-serif',
    themeVariables: {
      primaryColor: '#3b82f6',
      primaryTextColor: '#f8fafc',
      primaryBorderColor: '#64748b',
      lineColor: '#94a3b8',
      secondaryColor: '#1e293b',
      tertiaryColor: '#0f172a',
      fontFamily: 'Inter, sans-serif',
      fontSize: '16px'
    }
  });
</script>
